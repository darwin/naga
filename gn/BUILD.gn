import("//v8/gni/snapshot_toolchain.gni")
import("//v8/gni/v8.gni")

declare_args() {
  python_includes = string_split(getenv("STPYV8_PYTHON_INCLUDES"), " ")
  python_libs = string_split(getenv("STPYV8_PYTHON_LIBS"), " ")
  python_ldflags = string_split(getenv("STPYV8_PYTHON_LDFLAGS"), " ")

  boost_includes = string_split(getenv("STPYV8_BOOST_INCLUDES"), " ")
  boost_libs = string_split(getenv("STPYV8_BOOST_LIBS"), " ")
  boost_ldflags = string_split(getenv("STPYV8_BOOST_LDFLAGS"), " ")

  stpyv8_enable_precompiled_headers = true
}

stpyv8_source_files = [
  "Config.h",
  "Context.cpp",
  "Context.h",
  "Engine.cpp",
  "Engine.h",
  "Exception.cpp",
  "Exception.h",
  "Isolate.cpp",
  "Isolate.h",
  "JSObject.cpp",
  "JSObject.h",
  "JSObjectNull.cpp",
  "JSObjectNull.h",
  "JSObjectUndefined.cpp",
  "JSObjectUndefined.h",
  "JSObjectArray.cpp",
  "JSObjectArray.h",
  "JSObjectFunction.cpp",
  "JSObjectFunction.h",
  "JSObjectCLJS.cpp",
  "JSObjectCLJS.h",
  "Locker.cpp",
  "Locker.h",
  "Module.cpp",
  "Platform.cpp",
  "Platform.h",
  "PythonExceptionGuard.cpp",
  "PythonExceptionGuard.h",
  "PythonDateTime.cpp",
  "PythonDateTime.h",
  "PythonGIL.cpp",
  "PythonGIL.h",
  "PythonObject.cpp",
  "PythonObject.h",
  "PythonUtils.cpp",
  "PythonUtils.h",
  "Tracer.cpp",
  "Tracer.h",
  "V8Utils.cpp",
  "V8Utils.h",
]

stpyv8_source_file_paths = []

foreach(source, stpyv8_source_files) {
  stpyv8_source_file_paths += [ "../src/$source" ]
}

config("stpyv8_precompiled_headers") {
  if (stpyv8_enable_precompiled_headers) {
    if (is_win) {
      # This is a string rather than a file GN knows about. It has to match
      # exactly what's in the /FI flag below, and what might appear in the
      # source code in quotes for an #include directive.
      precompiled_header = "src/_precompile.h"

      # This is a file that GN will compile with the above header. It will be
      # implicitly added to the sources (potentially multiple times, with one
      # variant for each language used in the target).
      precompiled_source = "../src/_precompile.cpp"

      # Force include the header.
      cflags = [ "/FI$precompiled_header" ]
    } else if (is_mac) {
      precompiled_source = "../src/_precompile.h"
    }
  }
}

config("stpyv8_compiler_flags") {
  cflags_cc = [
    "-Wno-c++98-compat-extra-semi",
    "-Wno-error=unused-variable",

    # note CLion uses some unknown pragmas suppressing code hints
    "-Wno-unknown-pragmas",
    "-std=c++17",
  ]
}

config("stpyv8_python_compiler_flags") {
  cflags = python_includes
  ldflags = python_ldflags
}

config("stpyv8_boost_compiler_flags") {
  defines = [ "BOOST_PYTHON_STATIC_LIB" ]
  cflags = boost_includes
  ldflags = boost_ldflags
}

shared_library("stpyv8") {
  sources = stpyv8_source_file_paths

  # don't use the default configs that BUILDCONFIG applied to us.
  configs -= [
    "//build/config/compiler:no_exceptions",
    "//build/config/compiler:no_rtti",

    #"//build/config/compiler:default_symbols",

    # TODO: google's code conventions are quite strict
    #       revisit this after we get rid of boost
    "//build/config/clang:find_bad_constructs",
  ]

  # add some of our own settings...
  configs += [
    ":stpyv8_python_compiler_flags",
    ":stpyv8_boost_compiler_flags",
    ":stpyv8_compiler_flags",
    ":stpyv8_precompiled_headers",
  ]

  # this is very important
  # this will ensure our build uses the same headers as V8 build
  # see https://github.com/area1/stpyv8/issues/9
  configs += [ "//v8:external_config" ]

  output_extension = "so"

  deps = [
    "//v8:v8_libplatform",
    "//v8:v8_monolith",
  ]
}
